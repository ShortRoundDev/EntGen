# EntGen

## What is this?
This is a simple program for generating code (c++ files). The idea is that you have a config file (either a simple `key=value` formatted conf file, or an xml file with a single root node and a relatively simple format) which defines some information, and you can then generate instantiators for that information in C++ rather than writing some long if-then or switch-case by hand.

For example, say you have a game with a bunch of entities (hence the name EntGen). Each entity has an ID number associated with it (`player=1`, `skeleton=2`, `healthpack=3`, etc.). If you have a *map* file which defines a grid of integers to represent each enemy (or even a wall or tile) which should be loaded into the map, then you'll probably end up writing something like this when you load the map:

```cpp
//map is some 2d grid of integers

for(int i = 0; i < height; i++){
    for(int j = 0; j < width; j++){
        addEntity(map[i][j]);
    }
}

//...

void MapLoader::addEntity(int id){
    switch(id)
    {
    case 1:
        entities->push_back(new Player);
        break;
    case 2:
        entities->push_back(new Skeleton);
        break;
    // etc...
    }
}
```

And that *sucks* to write. You also have to `#include` every header, and if you want to have some kind of semantic relationship between the number and the class, you need to `#define` everything like `#define PLAYER 1`, and you need to make sure not to re-use IDs on accident, which would best be done some central file to define them in. C++ doesn't *currently* have the reflective capabilities of doing this, like C# or Java might with attributes.

So, the point of this program is to let you define these IDs or other information in a declarative way, and then generate the code using handlebars

## How do I do that?

The basic usage of the program is `EntGen.exe [config_file] [input_file_prefiex] [(optional) xml_root_node]`.

`config_file` is either a simple `key=value` conf formatted file, i.e:

```
Player=1
Skeleton=2
Healthpack=3
```

(more on XML later)

You create 2 .hbs files in your working directory: `[input_file_prefix].cpp.hbs` and `[input_file_prefix].h.hbs`. The former is the template to generate the C++ source file, and the latter is the template to generate the C++ header file. These templates use [handlebars](https://handlebarsjs.com/guide/) (specifically, [handlebars.net](https://github.com/Handlebars-Net/Handlebars.Net), and take in the key-value pairs of your configuration file.

## CFG Example
For example, a full CFG configuration might look like:

`EntityDefinitions.conf`
```
Player=1
Skeleton=2
HealthPack=3
```

`EntityDefinitions.h.hbs`
```hbs
{{!
    Say, for example, you have a base "Entity" class for all entities in your game
--}}
#include "Entity.h"

{{!
    key-values are loaded into an object called "pairs"
    which is a list of C# tuples (`List<(string, int)>`),
    so the "key" is `Item1` and the "value" is `Item2`
--}}

{{!
    The "Up" Handlebars helper performs a `String.ToUpper()` on the item
--}}
{{#each pairs}}
#define {{Up this.Item1}} {{this.Item2}}
{{/each}}

Entity* createEntity(int id);
```

`EntityDefinitions.cpp.hbs`
```hbs
{{!
    Include each entity's header file
--}}
{{#each pairs}}
#include "{{this.Item1}}.h"
{{/each}}

Entity* createEntity(int id)
{
    switch(id){
    {{#each pairs}}
    case {{Up this.Item1}}:
    {
        return new {{this.Item1}};
    }
    {{/each}}
    }
}
```

You would compile these with the following command, run from the directory where these files live:

```posh
EntGen.exe EntityDefinitions.conf EntityDefinitions
```

Which would generate the following:

`EntityDefinitions.h`
```cpp
#pragma once

/* !!!! DO NOT MODIFY THIS FILE !!!! * This file was generated by EntGen.exe. Your changes will be overridden on the next build
 * If you want to change this file, change the relevant entity config file, or change the
 * EntityDef.hbs template file
 */
#include "Entity.h"


#define PLAYER 1
#define SKELETON 2
#define HEALTHPACK 3

Entity* createEntity(int id);
```

Notice that, at the top, `#pragma once` has been automatically included in the header, as well as a warning comment to future developers, instructing them not the modify the generate file, as their changes will be wiped out.

Additionally, you will notice that the handlebars comments were not rendered in the C++ file. If there are comments you need to add for future developers, but don't want them to end up in the final generated source code, you can use handlebars comments instead of C++ comments

`EntityDefinitions.cpp`
```cpp
/* !!!! DO NOT MODIFY THIS FILE !!!! * This file was generated by EntGen.exe. Your changes will be overridden on the next build
 * If you want to change this file, change the relevant entity config file, or change the
 * EntityDef.hbs template file
 */
#include "EntityDefinitions.h"

#include "Player.h"
#include "Skeleton.h"
#include "HealthPack.h"

Entity* createEntity(int id)
{
    switch(id){
    case PLAYER:
    {
        return new Player;
    }
    case SKELETON:
    {
        return new Skeleton;
    }
    case HEALTHPACK:
    {
        return new HealthPack;
    }
    }
}
```

When loading your map, you can now simply pass in the integer from the map file to the `createEntity` function.

If you want to integrate the generated code into your build process, simply add the `EntGen` command to your pre-build events/tasks for whatever build system you use, and add the .cpp and .h files to your build

## XML

Lets say you have more complicated data, or you want your values to be strings instead of integers. You can additionally use an XML-formatted list of tags with attributes. If your entities are more complicated than simple OOP with inheritance (for example, you have some kind of ECS and find yourself reusing the same types of ECS combinations for the same types of enemies), you might define prefab entities in XML as such:

`Config.xml`
```xml
<?xml version="1.0" encoding="utf-8"?>
<entities>
    <!-- Adding &quot so that we can print this as a string on instantiation -->
    <entity Name="Skeleton" Id="1" Solid="true" Health="20" Model="&quot;Skeleton.obj&quot;"/>
    <entity Name="Ghost" Id="2" Solid="false" Model="&quot;Ghost.obj&quot;"/>
</entities>
```

`EntityCreator.h.hbs`
```hbs
{{!
    Much simpler this time, since we don't need to
    define constants for each entity in an ECS
--}}
Entity* createEntity(int id);
```

`EntityCreator.cpp.hbs`

```hbs
Entity* createEntity(int id)
{
    switch(id)
    {
        {{!
            "Entries" is a list of dictionary objects, where each key is an attribute
            and each value is the string value of that attribute
        --}}
        {{#each entries}}
        case {{this.Id}}:
        {
            Entity* e = new Entity;
            {{#if (Eq this.Solid "true")}}
            e->components.push_back(new PhysicsComponent());
            {{/if}}
            {{#if this.Health}}
            e->components.push_back(new KillableComponent({{{this.Health}}}));
            {{/if}}
            {{#if this.Model}}
            e->components.push_back(new DrawableComponent({{{this.Model}}})); 
            {{/if}}
            {{!
                We use triple brackets above to avoid HTML sanitation, since handlebars is
                originally designed for HTML. This lets us convert &quot to quotation marks
            --}}
        }
        {{/each}}
    }
}
```

Which will generate the following:

`EntityCreator.h`
```cpp
#pragma once

/* !!!! DO NOT MODIFY THIS FILE !!!! * This file was generated by EntGen.exe. Your changes will be overridden on the next build
 * If you want to change this file, change the relevant entity config file, or change the
 * EntityDef.hbs template file
 */
Entity* createEntity(int id);
```

`EntityCreator.cpp`
```cpp
/* !!!! DO NOT MODIFY THIS FILE !!!! * This file was generated by EntGen.exe. Your changes will be overridden on the next build
 * If you want to change this file, change the relevant entity config file, or change the
 * EntityDef.hbs template file
 */
#include "EntityCreator.h"

Entity* createEntity(int id)
{
    switch(id)
    {
        case 1:
        {
            Entity* e = new Entity;
            e->components.push_back(new PhysicsComponent());
            e->components.push_back(new KillableComponent(20));
            e->components.push_back(new DrawableComponent("Skeleton.obj"));
        }
        case 2:
        {
            Entity* e = new Entity;
            e->components.push_back(new DrawableComponent("Ghost.obj"));
        }
    }
}
```

If this hard-coded if-else is STILL too static for you, then you can take advantage of some of handlebar's faculties, such as the `@key` helper. The above `.cpp.hbs` could be re-written:

```cpp
Entity* createEntity(int id)
{
    switch(id)
    {
        {{!
            "Entries" is a list of dictionary objects, where each key is an attribute
            and each value is the string value of that attribute
        --}}
        {{#each entries}}
        case {{this.Id}}:
        {
            Entity* e = new Entity;
            {{#each this}}
            {{! ID and name are not components! }}
            {{#unless (Or (Eq @key "Id") (Eq @key "Name"))}}
            //{{@key}} = {{{this}}}
            e->components.push_back(new {{@key}}Component({{this}}));
            {{/unless}}
            {{/each}}
        }
        {{/each}}
    }
}
```

which will produce:

`EntityCreator.cpp`
```cpp
/* !!!! DO NOT MODIFY THIS FILE !!!! * This file was generated by EntGen.exe. Your changes will be overridden on the next build
 * If you want to change this file, change the relevant entity config file, or change the
 * EntityDef.hbs template file
 */
#include "EntityCreator.h"


Entity* createEntity(int id)
{
    switch(id)
    {
        case 1:
        {
            Entity* e = new Entity;
            //Solid = true
            e->components.push_back(new SolidComponent(true));
            //Health = 20
            e->components.push_back(new HealthComponent(20));
            //Model = "Skeleton.obj"
            e->components.push_back(new ModelComponent("Skeleton.obj"));
        }
        case 2:
        {
            Entity* e = new Entity;
            //Solid = false
            e->components.push_back(new SolidComponent(false));
            //Model = "Ghost.obj"
            e->components.push_back(new ModelComponent("Ghost.obj"));
        }
    }
}

```

This is by no means a perfect system, and currently requires you to hard code in formatting with your data, in this particular case. Perhaps in the future an XML Schema file can be included to indicate what type each attribute is for proper rendering. However, for my own uses this tool has been pretty useful so far.

## Errors

If there are any issues parsing out your config files, those errors will be written as compiler preprocessor errors. For example, if you malform a `conf` file:

```
BadKey=Bad=Value
MoreBadKey=More=Bad=Value
```

Then the output in your header will be:

