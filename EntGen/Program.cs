using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Xml;

using HandlebarsDotNet;

namespace EntGen
{
    class Program
    {
        static List<string> errors = new();
        static string headerText = "#pragma once\n\n";
        static string sourceText = ""; 
        static void Main(string[] args)
        {

            AppendHead(
                "/* !!!! DO NOT MODIFY THIS FILE !!!!" +
                " * This file was generated by EntGen.exe. Your changes will be overridden on the next build\n" +
                " * If you want to change this file, change the relevant entity config file, or change the\n" +
                " * EntityDef.hbs template file\n" +
                " */"
            );

            AppendSource(
                "/* !!!! DO NOT MODIFY THIS FILE !!!!" +
                " * This file was generated by EntGen.exe. Your changes will be overridden on the next build\n" +
                " * If you want to change this file, change the relevant entity config file, or change the\n" +
                " * EntityDef.hbs template file\n" +
                " */"
            );

            RegisterHelpers();

            if (args.Length < 2)
            {
                AppendHead("#error EntGen.exe failed! Build didn't pass a path or template!");
                goto flush;
            }
            else if (!File.Exists(args[0]))
            {
                AppendHead("#error EntGen.exe failed! Path does not exist at [" + args[0] + "]");
                goto flush;
            }
            else if (!File.Exists(args[1] + ".h.hbs") || !File.Exists(args[1] + ".cpp.hbs"))
            {
                AppendHead("#error EntGen.exe failed! Path does not exist at [" + args[1] + "]");
                goto flush;
            }

            AppendSource("#include \"" + args[1] + ".h\"\n\n");

            string text = File.ReadAllText(args[0]);
            if (args[0].EndsWith(".conf"))
            {
                var pairs = LoadPairs(text);

                string headerTempText = File.ReadAllText(args[1] + ".h.hbs");

                var headerTemplate = Handlebars.Compile(headerTempText);
                AppendHead(headerTemplate(new { pairs, errors }));

                string sourceTempText = File.ReadAllText(args[1] + ".cpp.hbs");

                var sourceTemplate = Handlebars.Compile(sourceTempText);
                AppendSource(sourceTemplate(new { pairs }));
            }else if (args[0].EndsWith(".xml"))
            {
                if(args.Length != 3) // 3rd arg = root query
                {
                    AppendHead("#error EntGen.exe failed! Root node not specified for XML config document!");
                    goto flush;
                }
                var entries = LoadEntries(text, args[2]);
                if (entries == null)
                {
                    goto flush;
                }

                string headerTempText = File.ReadAllText(args[1] + ".h.hbs");

                var headerTemplate = Handlebars.Compile(headerTempText);
                AppendHead(headerTemplate(new { entries, errors }));

                string sourceTempText = File.ReadAllText(args[1] + ".cpp.hbs");

                var sourceTemplate = Handlebars.Compile(sourceTempText);
                AppendSource(sourceTemplate(new { entries }));
            }

        flush:
            File.WriteAllText(args[1] + ".h", headerText);
            File.WriteAllText(args[1] + ".cpp", sourceText);
        }

        public static List<Dictionary<string, string>> LoadEntries(string Text, String Root)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(Text);
            var rootNode = doc.GetElementsByTagName(Root)[0];
            if(rootNode == null)
            {
                AppendHead("#error Root node [" + Root + "] does not exist in config file!");
                return null;
            }
            var entries = new List<Dictionary<string, string>>();
            foreach (var element in rootNode.ChildNodes.Cast<XmlNode>().Where(c => c is XmlElement))
            {
                var dict = new Dictionary<string, string>();
                foreach(var attribute in element.Attributes.Cast<XmlAttribute>())
                {
                    dict.Add(attribute.Name, attribute.Value);
                }
                entries.Add(dict);
            }
            return entries;
        }

        public static List<(string Ent, int Id)> LoadPairs(string Config)
        {
            List<(string Ent, int Id)> entPairs = new();
            var SR = new StringReader(Config);
            string line = "";
            for(int lineNo = 1; ((line = SR.ReadLine()) != null); lineNo++)
            {
                if (string.IsNullOrWhiteSpace(line))
                {
                    continue;
                }
                var parts = line.Split('=');
                if (parts.Length != 2)
                {
                    Error($"Invalid ent config on line {lineNo}. Got '{line}'");
                    continue;
                }
                var trimmed = parts.Select(s => s.Trim()).ToArray();

                var ent = trimmed[0];
                if(!Int32.TryParse(trimmed[1], out int id)){
                    Error($"Invalid ID for Ent '{ent}' at line {lineNo}! Got '{trimmed[1]}'");
                    continue;
                }
                entPairs.Add((ent, id));
            }
            return entPairs;
        }

        public static void Error(string Error) {
            errors.Add(Error);
        }

        public static void AppendHead(string head)
        {
            headerText += head + "\n";
        }

        public static void AppendSource(string source)
        {
            sourceText += source + "\n";
        }

        public static void RegisterHelpers()
        {
            Handlebars.RegisterHelper("Up", (writer, context, parameters) =>
            {
                if(parameters.Count() != 1 || parameters[0] is not string s)
                {
                    return;
                }
                writer.Write(s.ToUpper());
            });

            Handlebars.RegisterHelper("Eq", (writer, context, parameters) =>
            {
                if(parameters.Count() != 2)
                {
                    return;
                }
                bool equal = parameters[0].ToString() == parameters[1].ToString();
                if (equal)
                {
                    writer.Write(true);
                }
            });

            Handlebars.RegisterHelper("Not", (writer, context, parameters) =>
            {
                if (parameters.Count() != 1)
                {
                    writer.Write(true);
                }

                if(parameters[0] is not bool b)
                {
                    if (!Boolean.TryParse(parameters[0].ToString(), out b))
                    {
                        writer.Write(true);
                    }
                }
                if (!b)
                {
                    writer.Write(true);
                }
            });
        }
    }
}
